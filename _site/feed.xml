<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>前端栗仔 | Thinking in Front-end</title>
    <description>Thinking in Front-end</description>
    <link>http://blog.comiclee.com/</link>
    <atom:link href="http://blog.comiclee.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 13 Dec 2015 23:27:02 +0800</pubDate>
    <lastBuildDate>Sun, 13 Dec 2015 23:27:02 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>icomoon生成的字体在安卓的一些浏览器上无法显示的问题</title>
        <description>&lt;p&gt;这个bug发生的条件不普遍，就是在小米2上的微信webview中，原想跳过不管的，不过由于不知道还有哪些机器会受此牵连，这会极大影响我使用icon fonts的信心，故上网搜搜有没有解决方案，终于找到解决方案，还挺简单的。&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;详见这篇文章&lt;a href=&quot;http://www.cnblogs.com/Megasu/p/4305116.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/Megasu/p/4305116.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;总结一下挺简单的，icomoon生成的font排列顺序是：&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;@font-face {font-family: &quot;iconfont&quot;;
  src: url(&#39;iconfont.eot&#39;); /* IE9*/
  src: url(&#39;iconfont.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;), /* IE6-IE8 */
  url(&#39;iconfont.woff&#39;) format(&#39;woff&#39;), /* chrome、firefox */
  url(&#39;iconfont.ttf&#39;) format(&#39;truetype&#39;), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/
  url(&#39;iconfont.svg#iconfont&#39;) format(&#39;svg&#39;); /* iOS 4.1- */
}&lt;/pre&gt;

&lt;p&gt;我们调节一下加载顺序，改成eto,svg,woff,ttf(把SVG放到前面) 即可&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true&quot;&gt;@font-face {font-family: &quot;iconfont&quot;;
  src: url(&#39;../font/iconfont.eot&#39;); /* IE9*/
  src: url(&#39;../font/iconfont.svg#iconfont&#39;) format(&#39;svg&#39;), /* iOS 4.1- */
  url(&#39;../font/iconfont.woff&#39;) format(&#39;woff&#39;), /* chrome、firefox */
  url(&#39;../font/iconfont.ttf&#39;) format(&#39;truetype&#39;); /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/ 
}&lt;/pre&gt;

&lt;p&gt; &lt;/p&gt;
</description>
        <pubDate>Sat, 19 Sep 2015 00:00:00 +0800</pubDate>
        <link>http://blog.comiclee.com/2015/09/icomoon%e7%94%9f%e6%88%90%e7%9a%84%e5%ad%97%e4%bd%93%e5%9c%a8%e5%ae%89%e5%8d%93%e7%9a%84%e4%b8%80%e4%ba%9b%e6%b5%8f%e8%a7%88%e5%99%a8%e4%b8%8a%e6%97%a0%e6%b3%95%e6%98%be%e7%a4%ba%e7%9a%84%e9%97%ae</link>
        <guid isPermaLink="true">http://blog.comiclee.com/2015/09/icomoon%e7%94%9f%e6%88%90%e7%9a%84%e5%ad%97%e4%bd%93%e5%9c%a8%e5%ae%89%e5%8d%93%e7%9a%84%e4%b8%80%e4%ba%9b%e6%b5%8f%e8%a7%88%e5%99%a8%e4%b8%8a%e6%97%a0%e6%b3%95%e6%98%be%e7%a4%ba%e7%9a%84%e9%97%ae</guid>
        
        
        <category>移动前端</category>
        
      </item>
    
      <item>
        <title>开始使用input事件</title>
        <description>&lt;p&gt;在pc时代，我们习惯于使用keyup或keydow事件来实时监听输入框的输入，但在移动设备上可能会有些问题，例如最近在项目中发现，iphone的搜狗输入法输入时并没有触发keyup或keydown事件，导致对这两个事件的监听失败。&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;最简单的解决方法就是使用input事件。input事件是HTML5的标准事件，虽然在IE只有IE9以上才支持，但在移动设备上还是支持得挺好的，代码就不写了，直接把keyup/keydown事件替换成input事件即可。&lt;/p&gt;
</description>
        <pubDate>Sat, 19 Sep 2015 00:00:00 +0800</pubDate>
        <link>http://blog.comiclee.com/2015/09/%e5%bc%80%e5%a7%8b%e4%bd%bf%e7%94%a8input%e4%ba%8b%e4%bb%b6</link>
        <guid isPermaLink="true">http://blog.comiclee.com/2015/09/%e5%bc%80%e5%a7%8b%e4%bd%bf%e7%94%a8input%e4%ba%8b%e4%bb%b6</guid>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>word-wrap,word-break和white-space</title>
        <description>&lt;p&gt;word-wrap、word-break和white-space这3个属性影响着页面文章的排版，它们看起来比较接近，容易让人混淆。本文就仔细讨论一下他们的用法，让人们理解它们的作用和使用场景，就能更好地掌握页面的排版。&lt;!--more--&gt;&lt;/p&gt;

&lt;h1 id=&quot;word-wrap&quot;&gt;word-wrap&lt;/h1&gt;

&lt;p&gt;word-wrap这个属性源自微软的IE浏览器（所以它的浏览器兼容性是很好的），它只有一个功能——设置当一个英文单词太长以致超出容器时，是否将其截断。它有两个取值：&lt;/p&gt;

&lt;table class=&quot;dataintable&quot;&gt;
  &lt;tr&gt;
    &lt;th&gt;
      值
    &lt;/th&gt;
    
    &lt;th&gt;
      描述
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      normal
    &lt;/td&gt;
    
    &lt;td&gt;
      只在允许的断字点换行（浏览器保持默认处理）。
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      break-word
    &lt;/td&gt;
    
    &lt;td&gt;
      在长单词或 URL 地址内部进行换行。
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;默认取值是normal，也就是说长单词不会在中间断行，而是会直接超出去，并且长单词会另起一行放置，如下面这个例子：&lt;/p&gt;

&lt;div style=&quot;width: 50px; border: 1px dotted gray; word-wrap: normal;&quot;&gt;
  你是abcdefghijklmnop吗？
&lt;/div&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;大多数情况我们是不想要这样的，我们希望长单词在中间断行，以满足容器尺寸的限制，那么我们就可以加上 &lt;span class=&quot;lang:css decode:true  crayon-inline &quot;&gt;word-wrap:break-word&lt;/span&gt; ，效果如下：&lt;/p&gt;

&lt;div style=&quot;width: 50px; border: 1px dotted gray; word-wrap: break-word;&quot;&gt;
  你是abcdefghijklmnop吗？
&lt;/div&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;虽然单词截断了，但也不太影响阅读，布局也美观了。&lt;/p&gt;

&lt;h1 id=&quot;word-break&quot;&gt;word-break&lt;/h1&gt;

&lt;p&gt;那word-break是什么作用呢？我们发现刚才用word-wrap仍然没有完美解决问题，看如下的例子：&lt;/p&gt;

&lt;div style=&quot;width: 100px; border: 1px dotted gray; word-wrap: break-word;&quot;&gt;
  你是abcdefghijklmnop吗？
&lt;/div&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;虽然长单词截断了，但单词还是另起一行放置，这仍然不够美观，于是word-break就登场了。word-break设置怎样在单词内断行。一般文档都没有太详细的介绍&lt;/p&gt;

&lt;table class=&quot;dataintable&quot;&gt;
  &lt;tr&gt;
    &lt;td&gt;
      normal
    &lt;/td&gt;
    
    &lt;td&gt;
      使用浏览器默认的换行规则。
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      break-all
    &lt;/td&gt;
    
    &lt;td&gt;
      允许在单词内换行。
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      keep-all(chrome未实现)
    &lt;/td&gt;
    
    &lt;td&gt;
      只能在半角空格或连字符处换行。
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;由于keep-all值在chrome和opera中未实现，所以使用得比较少，我们常常用的是break-all，使用后的效果如下：&lt;/p&gt;

&lt;div style=&quot;width: 100px; border: 1px dotted gray; word-wrap: normal; word-break: break-all;&quot;&gt;
  你是abcdefghijklmnop吗？
&lt;/div&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;这就是我们常常看到的&lt;span class=&quot;lang:js decode:true  crayon-inline&quot;&gt;word-wrap:break-word; word-break:break-all;&lt;/span&gt; 组合用法的效果。&lt;/p&gt;

&lt;p&gt;以上的属性的显示效果在桌面浏览器上是ok的，但在手机浏览器safari上，会出现标点符号居于行首的问题。这在文章的排版中是要尽量避免的。经试验，设置&lt;span class=&quot;lang:js decode:true  crayon-inline &quot;&gt;word-break:normal&lt;/span&gt; 就不会有这个问题，但又回到了刚才的讨论，这需要结合场景来讨论。在没有长单词的情况下，我们大可以设置&lt;span class=&quot;lang:js decode:true  crayon-inline &quot;&gt;word-break:normal&lt;/span&gt; 以避免出现标点符号出现在行首的问题。&lt;/p&gt;

&lt;h1 id=&quot;white-space&quot;&gt;white-space&lt;/h1&gt;

&lt;p&gt;最后说说white-space，这个属性用于指示如何处理文本中的空白，空白包括空格、换行符等空白字符。我们最常用的是nowrap属性，即文本不换行，用上这个属性后，word-wrap和word-break都形同虚设，所有都不会换行了。&lt;/p&gt;

&lt;table class=&quot;dataintable&quot;&gt;
  &lt;tr&gt;
    &lt;td&gt;
      normal
    &lt;/td&gt;
    
    &lt;td&gt;
      默认。空白会被浏览器忽略。
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      pre
    &lt;/td&gt;
    
    &lt;td&gt;
      空白会被浏览器保留。其行为方式类似 HTML 中的 &lt;pre&gt; 标签。
    
  
  
  &lt;tr&gt;
    &lt;td&gt;
      nowrap
    &lt;/td&gt;
    
    &lt;td&gt;
      文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br /&gt; 标签为止。
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      pre-wrap
    &lt;/td&gt;
    
    &lt;td&gt;
      保留空白符序列，但是正常地进行换行。
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      pre-line
    &lt;/td&gt;
    
    &lt;td&gt;
      合并空白符序列，但是保留换行符。
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      inherit
    &lt;/td&gt;
    
    &lt;td&gt;
      规定应该从父元素继承 white-space 属性的值。
    &lt;/td&gt;
  &lt;/tr&gt;


下表能更清晰地分辨出各属性值的功能

&lt;table class=&quot;dataintable&quot;&gt;
  &lt;tr&gt;
    &lt;th&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      换行符
    &lt;/th&gt;
    
    &lt;th&gt;
      空格和制表符
    &lt;/th&gt;
    
    &lt;th&gt;
      文字转行
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;span style=&quot;font-family: Consolas, Monaco, &#39;Lucida Console&#39;, monospace;&quot;&gt;nomal&lt;/span&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      合并
    &lt;/td&gt;
    
    &lt;td&gt;
      合并
    &lt;/td&gt;
    
    &lt;td&gt;
      转行
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;nowrap&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      合并
    &lt;/td&gt;
    
    &lt;td&gt;
      合并
    &lt;/td&gt;
    
    &lt;td&gt;
      不转行
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;pre&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      保留
    &lt;/td&gt;
    
    &lt;td&gt;
      保留
    &lt;/td&gt;
    
    &lt;td&gt;
      不转行
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;pre-wrap&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      保留
    &lt;/td&gt;
    
    &lt;td&gt;
      保留
    &lt;/td&gt;
    
    &lt;td&gt;
      转行
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;pre-line&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      保留
    &lt;/td&gt;
    
    &lt;td&gt;
      合并
    &lt;/td&gt;
    
    &lt;td&gt;
      转行
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&amp;nbsp;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
</description>
        <pubDate>Fri, 07 Aug 2015 00:00:00 +0800</pubDate>
        <link>http://blog.comiclee.com/2015/08/word-wrapword-break%e5%92%8cwhite-space</link>
        <guid isPermaLink="true">http://blog.comiclee.com/2015/08/word-wrapword-break%e5%92%8cwhite-space</guid>
        
        
        <category>css</category>
        
      </item>
    
      <item>
        <title>Date的迷思</title>
        <description>&lt;p&gt;不得不说Javascript的Date类的功能实在比较弱，没有format功能，导致创建和打印的时候都要多费一些代码。对于创建Date对象，有四种方法可以用：&lt;!--more--&gt;&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;new Date();
new Date(value);
new Date(dateString);
new Date(year, month, day, hour, minute, second, millisecond);&lt;/pre&gt;

&lt;p&gt;其中1、2、4的参数比较确定，不用多说。而方法3的dateString是什么格式？这是需要注意的地方。该参数的解释是这样的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;表示日期的字符串值。该字符串应该能被 Date.parse() 方法识别（符合 &lt;a href=&quot;http://tools.ietf.org/html/rfc2822#page-14&quot; target=&quot;_blank&quot;&gt;IETF-compliant RFC 2822 timestamps&lt;/a&gt; 或 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15&quot; target=&quot;_blank&quot;&gt;version of ISO8601&lt;/a&gt;）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;写这种字符串是什么体验？&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true&quot;&gt;new Date(&quot;Apr 14, 2015&quot;);
new Date(&quot;Tue, 14 Apr 2015 21:06:25 GMT+0800&quot;);&lt;/pre&gt;

&lt;p&gt;这种不太符合中国人习惯的风格写起来真是别扭啊。需要摸索一个简洁的写法，比如说”2015-04-14″，这种格式行不行呢？在几款浏览器下做了实验，并不是完全兼容的。&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      Chrome
    &lt;/th&gt;
    
    &lt;th&gt;
      IE9,10
    &lt;/th&gt;
    
    &lt;th&gt;
      IE6-8
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
       new Date(&amp;#8216;2015-04-14&amp;#8242;)
    &lt;/td&gt;
    
    &lt;td&gt;
       &lt;span style=&quot;color: #ff0000;&quot;&gt;Tue Apr 14 2015 08:00:00 GMT+0800 (CST)&lt;/span&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;span style=&quot;color: #ff0000;&quot;&gt; Tue Apr 14 08:00:00 UTC+0800 2015&lt;/span&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;span style=&quot;color: #ff0000;&quot;&gt; NaN&lt;/span&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      new Date(&amp;#8216;2015-4-14&amp;#8242;)
    &lt;/td&gt;
    
    &lt;td&gt;
       Tue Apr 14 2015 00:00:00 GMT+0800 (CST)
    &lt;/td&gt;
    
    &lt;td&gt;
        &lt;span style=&quot;color: #ff0000;&quot;&gt;Invalid Date&lt;/span&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
       &lt;span style=&quot;color: #ff0000;&quot;&gt;NaN&lt;/span&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      new Date(&amp;#8216;2015-04-14 21:12:25&amp;#8242;)
    &lt;/td&gt;
    
    &lt;td&gt;
       Tue Apr 14 2015 21:12:25 GMT+0800 (CST)
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;span style=&quot;color: #ff0000;&quot;&gt; Invalid Date&lt;/span&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;span style=&quot;color: #ff0000;&quot;&gt; NaN&lt;/span&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
       new Date(&amp;#8216;2015-4-14 21:12:25&amp;#8242;)
    &lt;/td&gt;
    
    &lt;td&gt;
       Tue Apr 14 2015 21:12:25 GMT+0800 (CST)
    &lt;/td&gt;
    
    &lt;td&gt;
       &lt;span style=&quot;color: #ff0000;&quot;&gt;Invalid Date&lt;/span&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
       &lt;span style=&quot;color: #ff0000;&quot;&gt;NaN&lt;/span&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
       new Date(&amp;#8216;2015/04/14&amp;#8242;)
    &lt;/td&gt;
    
    &lt;td&gt;
      Tue Apr 14 2015 00:00:00 GMT+0800 (CST)
    &lt;/td&gt;
    
    &lt;td&gt;
      Tue Apr 14 00:00:00 UTC+0800 2015
    &lt;/td&gt;
    
    &lt;td&gt;
       Tue Apr 14 00:00:00 UTC+0800 2015
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      new Date(&amp;#8216;2015/4/14&amp;#8242;)
    &lt;/td&gt;
    
    &lt;td&gt;
      Tue Apr 14 2015 00:00:00 GMT+0800 (CST)
    &lt;/td&gt;
    
    &lt;td&gt;
       Tue Apr 14 00:00:00 UTC+0800 2015
    &lt;/td&gt;
    
    &lt;td&gt;
      Tue Apr 14 00:00:00 UTC+0800 2015
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
       new Date(&amp;#8217;15/04/14&amp;#8242;)
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;span style=&quot;color: #ff0000;&quot;&gt; Invalid Date&lt;/span&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
       &lt;span style=&quot;color: #ff0000;&quot;&gt;Thu Mar 4 00:00:00 UTC+0800 1915&lt;/span&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
       &lt;span style=&quot;color: #ff0000;&quot;&gt;Thu Mar 4 00:00:00 UTC+0800 1915&lt;/span&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
       new Date(&amp;#8216;2015/04/14 21:06:25&amp;#8242;)
    &lt;/td&gt;
    
    &lt;td&gt;
       Tue Apr 14 2015 21:06:25 GMT+0800 (CST)
    &lt;/td&gt;
    
    &lt;td&gt;
       Tue Apr 14 21:06:25 UTC+0800 2015
    &lt;/td&gt;
    
    &lt;td&gt;
      Tue Apr 14 21:06:25 UTC+0800 2015
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      new Date(&amp;#8216;2015/4/14 21:6:25&amp;#8242;)
    &lt;/td&gt;
    
    &lt;td&gt;
      Tue Apr 14 21:06:25 UTC+0800 2015
    &lt;/td&gt;
    
    &lt;td&gt;
       Tue Apr 14 21:06:25 UTC+0800 2015
    &lt;/td&gt;
    
    &lt;td&gt;
      Tue Apr 14 21:06:25 UTC+0800 2015
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;从以上浏览器的比较中可以看出形如”yyyy-MM-dd”在IE中的兼容性不佳，亦有时区的问题。而&lt;strong&gt;“yyyy/MM/dd”&lt;/strong&gt;以及&lt;strong&gt;“yyyy/MM/dd HH:mm:ss”&lt;/strong&gt;在各浏览器下的兼容性比较好，推荐使用这个。&lt;/p&gt;
</description>
        <pubDate>Wed, 29 Jul 2015 00:00:00 +0800</pubDate>
        <link>http://blog.comiclee.com/2015/07/date%e7%9a%84%e8%bf%b7%e6%80%9d</link>
        <guid isPermaLink="true">http://blog.comiclee.com/2015/07/date%e7%9a%84%e8%bf%b7%e6%80%9d</guid>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>Javascript的严格模式</title>
        <description>&lt;p&gt;ECMAScript5定义了一种严格模式的语法，它禁用了一些不够安全的用法，同时，对一些原本静默失败的异常情况会抛出错误。使用严格模式可以帮助我们避免因为失误写出不安全的代码，我们应该尽量使用它。&lt;!--more--&gt;&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;启用严格模式&lt;/h1&gt;

&lt;p&gt;使用&lt;span class=&quot;lang:js decode:true  crayon-inline&quot;&gt;“use strict”;&lt;/span&gt;  或者 &lt;span class=&quot;lang:js decode:true  crayon-inline &quot;&gt;‘use strict’;&lt;/span&gt;  可以指定特定的代码使用严格模式，如我们可以指定对单个函数启用严格模式。如果我们在全局使用严格模式，那么会影响到所有的代码，这可能导致一些旧代码执行出错，所以我们应该把严格模式的代码控制在我们所掌握的范围内。&lt;/p&gt;

&lt;p&gt;要注意的是，&lt;span class=&quot;lang:js decode:true  crayon-inline&quot;&gt;“use strict”;&lt;/span&gt; 应该放在代码的顶端才能生效，放在中间是不生效的。请看下面的例子：&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true&quot;&gt;// OK, non-strict mode
(function foo() {
  arguments = 10;
  &quot;use strict&quot;;
})();
 
// SyntaxError, strict-mode
(function foo() {
  &quot;use strict&quot;;
  arguments = 10;
})();&lt;/pre&gt;

&lt;p&gt;当然，这个顶端指的是可执行代码之前，倒不必非是第一行代码：&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;// also strict mode
 
&quot;use restrict&quot;;
&quot;use strict&quot;;
 
a = 10; // ReferenceError&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt; 严格模式的作用域&lt;/h1&gt;

&lt;p&gt;严格模式的作用域延伸到其所有内部代码，定义了严格模式的代码，其内部嵌套的代码都处于严格模式中：&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;// define strict mode in the global context,
// i.e. for the whole program
&quot;use strict&quot;;
 
(function foo() {
  // strictness is &quot;inherited&quot; from
  // the global context
  eval = 10; // SyntaxError
  (function bar() {
    // the same - from the global context
    arguments = 10; // SyntaxError
  })();
})();&lt;/pre&gt;

&lt;p&gt;需要明确一点是，严格模式作用于词法上下文（静态上下文）而非运行时环境，即在定义的时候其作用域就已经确定了，而非运行时才确定，这一点和闭包一样：&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;// globally use a non-strict mode
 
var foo = (function () {
  &quot;use strict&quot;;
  return function () {
    alert(this);
  };
})();
 
function bar() {
  alert(this);
}
 
// for both functions, a caller is the global context
 
// but &quot;foo&quot; is evaluated in the strict mode
foo(); // undefined
 
// meanwhile &quot;bar&quot; is not
bar(); // object&lt;/pre&gt;

&lt;p&gt;另外提及一点，使用Function构造函数创造的函数不会继承定义时的环境的严格模式：&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;&quot;use strict&quot;;
 
var f = Function(&quot;eval&quot;, &quot;arguments&quot;, &quot; \
  eval = 10; arguments = 20; \
  with ({a: 30}) { \
    alert(a + eval + arguments); \
  }&quot;
);
 
f(); // OK, 60&lt;/pre&gt;

&lt;p&gt;除非把 &lt;span class=&quot;lang:js decode:true  crayon-inline&quot;&gt;“use strict”;&lt;/span&gt; 放在函数定义中：&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;// non-strict globally
 
var f = Function(&quot;eval&quot;, &quot;&#39;use strict&#39;; alert(eval);&quot;); // SyntaxError&lt;/pre&gt;

&lt;h1 id=&quot;section-2&quot;&gt; 严格模式下的代码要求和限制&lt;/h1&gt;

&lt;p&gt;我们看看在严格模式下有哪些代码的要求和限制&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;为未来预留的关键字&lt;/h2&gt;

&lt;p&gt;这些关键字是为未来预留的，所以不能用于变量名和函数名中：&lt;em&gt;implements&lt;/em&gt;, &lt;em&gt;interface&lt;/em&gt;, &lt;em&gt;let&lt;/em&gt;, &lt;em&gt;package&lt;/em&gt;, &lt;em&gt;private&lt;/em&gt;, &lt;em&gt;protected&lt;/em&gt;, &lt;em&gt;public&lt;/em&gt;, &lt;em&gt;static&lt;/em&gt;, &lt;em&gt;yield&lt;/em&gt; 。&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;&quot;use strict&quot;;
 
var let = 10; // SyntaxError&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt; 不支持八进制字面量&lt;/h2&gt;

&lt;p&gt;在非严格模式中，数字第一位是0会被解析成八进制数字：&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;var x = 010; // octal number
print(x); // 8 - in octal radix&lt;/pre&gt;

&lt;p&gt;这样的做法仅仅是为了向后兼容，但在严格模式下，这样的写法不被支持了，这么写将会报错：&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;&quot;use strict&quot;;
 
var x = 010; // SyntaxError&lt;/pre&gt;

&lt;p&gt;另外提一点，在ES3中使用 &lt;span class=&quot;lang:js decode:true  crayon-inline &quot;&gt;parseInt(‘010′)&lt;/span&gt; 会默认转成八进制数字，不过这在ES5中已经改为转换成十进制数字了，不管有没有严格模式。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt; 给未声明的变量赋值&lt;/h2&gt;

&lt;p&gt;众所周知，给未声明的变量赋值会自动创建一个全局作用域的变量，这是一种非常不安全的行为：&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;// non-strict mode
 
(function foo() {
  // local vars
  var x = y = 20;
})();
 
// unfortunately, &quot;y&quot; wasn&#39;t local
// for &quot;foo&quot; function
alert(y); // 20
alert(x); // &quot;x&quot; is not defined&lt;/pre&gt;

&lt;p&gt;但在严格模式下，这么做将会报错：&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;&quot;use strict&quot;;
a = 10; // ReferenceError
 
var x = y = 20; // also a ReferenceError&lt;/pre&gt;

&lt;h2 id=&quot;eval-arguments&quot;&gt;eval 和 arguments&lt;/h2&gt;

&lt;p&gt;在严格模式下，eval和arguments被当作关键词。它们不能用作变量名、函数名、函数的参数名，不能给它们赋值，不能进行自增、自减操作：&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true&quot;&gt;&quot;use strict&quot;;
 
// SyntaxError in both cases
var arguments;
var eval;
 
// also SyntaxError
function eval() {}
var foo = function arguments() {};

// SyntaxError
function foo(eval, arguments) {}

(function (x) {
  alert(arguments[0]); // 30
  arguments = 40; // TypeError
})(30);

// SyntaxError
++eval;
arguments--;

try {
  throw Error(&quot;...&quot;);
} catch (arguments) {} // SyntaxError, the same for &quot;eval&quot; name&lt;/pre&gt;

&lt;p&gt;它们可以作为对象的属性名，不过不能作为函数的属性名&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true&quot;&gt;&quot;use strict&quot;;
 
// OK
var foo = {
  eval: 10,
  arguments: 20
};
 
// OK
foo.eval = 10;
foo.arguments = 20;&lt;/pre&gt;

&lt;pre class=&quot;lang:js decode:true&quot;&gt;&quot;use strict&quot;;
 
function foo() {
  alert(foo.arguments); // SyntaxError
  alert(foo.caller); // SyntaxError
}
 
foo();&lt;/pre&gt;

&lt;p&gt;arguments和函数参数之间的绑定将会断开，即更改一个不会影响到另一个&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;&quot;use strict&quot;;
 
(function foo(x) {
 
  alert(arguments[0]); // 10
  arguments[0] = 20;
 
  alert(x); // 10, but not 20
 
  x = 30;
  alert(arguments[0]); // 20, but not 30
 
})(10);&lt;/pre&gt;

&lt;p&gt;eval执行在一个沙盒环境中，在其中声明的变量不会影响到全局的作用域，在eval结束后，沙盒环境也相应地消失。&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;&quot;use strict&quot;;
 
eval(&quot;var x = 10; alert(x);&quot;); // 10
alert(x); // &quot;x&quot; is not defined&lt;/pre&gt;

&lt;p&gt;不过我们可以通过 indirect eval 来让eval创建全局变量。&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;&quot;use strict&quot;;
 
(&quot;indirect&quot;, eval)(&quot;var x = 10; alert(x);&quot;); // 10
alert(x); // 10&lt;/pre&gt;

&lt;h2 id=&quot;callee--caller&quot;&gt;callee 和 caller&lt;/h2&gt;

&lt;p&gt;在严格模式下，callee和caller都被禁止访问。我们无法使用arguments.callee来获取匿名函数了&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;&quot;use strict&quot;;
 
(function foo(bar) {
  if (!bar) {
    arguments.callee(true); // SyntaxError
    foo(true); // OK
  }
})();&lt;/pre&gt;

&lt;p&gt;这是处于安全性的考虑，如果没有这样的限制，被调用函数有权限修改调用方的值，比如：&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;// non-strict mode
 
function foo(x, y) {
  alert(x); // 10
  bar();
  alert(x); // 100
}
 
function bar() {
  console.dir(bar.caller.arguments); // 10, 20
  bar.caller.arguments[0] = 100;
}
 
foo(10, 20);&lt;/pre&gt;

&lt;p&gt;禁止访问arguments.callee后会引发一些不便，比如在非全局作用域下，用Function创建函数，且这个函数存在递归调用的时候：&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;(function () {
   
  // outer name is not available,
  // regardless strictness
  var foo = Function(&quot;alert(foo);&#39;&quot;);
  foo(); // &quot;foo&quot; is not defined (no such name in the global context)
   
  // error in strict mode for arguments.callee
  Function(&quot;&#39;use strict; alert(arguments.callee);&#39;&quot;)(); // TypeError
   
  // OK in non-strict for arguments.callee
  Function(&quot;alert(arguments.callee);&#39;&quot;)(); // OK, function
 
})();&lt;/pre&gt;

&lt;p&gt;有一些方法可以绕过去，这里就不展开了，可以见&lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/#codecalleecode-and-codecallercode-restrictions&quot; target=&quot;_blank&quot;&gt;http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/#codecalleecode-and-codecallercode-restrictions&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;重复命名&lt;/h2&gt;

&lt;p&gt;重复命名将会报错，包括属性名和参数名&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;&quot;use strict&quot;;
 
// SyntaxError
var foo = {
  x: 10,
  x: 10
};

// SyntaxError
function foo(x, x) {}&lt;/pre&gt;

&lt;p&gt;get和set方法在严格或非严格的模式下，都不能重名&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;// strict or non-strict mode
 
// SyntaxError
var foo = {
  get x() {},
  get x() {}
};
 
// the same with setters
// SyntaxError
var bar = {
  set y(value) {},
  set y(value) {}
};

// SyntaxError
var foo = {
  x: 10,
  get x() {}
};&lt;/pre&gt;

&lt;h2 id=&quot;delete&quot;&gt; delete操作&lt;/h2&gt;

&lt;p&gt;实际上，变量、函数参数、函数都是无法被删除的，除非是在eval环境中，不过无法删除并不会报错。而在严格模式下，删除变量、函数参数、函数都会报错，包括在eval环境中删除也会报错。&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;&quot;use strict&quot;;
 
var foo = {};
 
function bar(x) {
  delete x; // SyntaxError
}
 
bar(10);  // SyntaxError
 
delete foo; // SyntaxError
delete bar; // SyntaxError
 
Object.defineProperty(foo, &quot;baz&quot;, {
  value: 10,
  configurable: false
});
 
// but when delete a
// property, then TypeError
 
delete foo.baz; // TypeError
 
// SyntaxError
eval(&quot;var x = 10; delete x;&quot;); // in non-strict is OK&lt;/pre&gt;

&lt;h2 id=&quot;with&quot;&gt;with语句&lt;/h2&gt;

&lt;p&gt;在严格模式下，不允许使用with语句&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;&quot;use strict&quot;;
 
// SyntaxError
with ({a: 10}) {
  alert(a);
}&lt;/pre&gt;

&lt;h2 id=&quot;this&quot;&gt;this值&lt;/h2&gt;

&lt;p&gt;在严格模式中，this值不再自动转换成一个对象， null和undefined的this值不再转换成全局对象，基本类型的值不再转换成包装对象，通过 &lt;span class=&quot;lang:js decode:true  crayon-inline &quot;&gt;Function.prototype.apply&lt;/span&gt; 和 &lt;span class=&quot;lang:js decode:true  crayon-inline &quot;&gt;Function.prototype.call&lt;/span&gt; 传入的this值不再转换成对象：&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;&quot;use strict&quot;;
 
// undefined &quot;this&quot; value,
// but not the global object
function foo() {
  alert(this); // undefined
}
 
foo(); // undefined
 
// &quot;this&quot; is a primitive
Number.prototype.test = function () {
  alert(typeof this); // number
};
 
1..test(); // number
 
foo.call(null); // null
foo.apply(undefined); // undefined&lt;/pre&gt;

&lt;p&gt;this被设置为undefined可以避免忘记使用new 来调用构造函数&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;// non-strict
function A(x) {
  this.x = x;
}
 
var a = A(10); // forget &quot;new&quot; keyword
 
// as a result &quot;a&quot; is undefined,
// because exactly this value is returned
// implicitly from the A function
 
alert(a); // undefined
 
// and again created &quot;x&quot; property
// of the global object, because &quot;this&quot;
// is coerced to global object in the
// non-strict in such case
 
alert(x); // 10&lt;/pre&gt;

&lt;p&gt;在严格模式下会抛出异常&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true &quot;&gt;&quot;use strict&quot;;
 
function A(x) {
  this.x = x;
}
 
// forget &quot;new&quot; keyword,
// error, because undefined.x = 10
 
var a = A(10);
 
var b = new A(10); // OK&lt;/pre&gt;

&lt;h1 id=&quot;section-7&quot;&gt;总结&lt;/h1&gt;

&lt;p&gt;可以看到，严格模式限制了Javascript现有的一些有风险的做法，减少了我们出错的几率。同时一些将来会废弃的用法，在严格模式中也禁用了，所以启用严格模式也能避免产生一些历史遗留代码。IE10+才支持严格模式，在低版本下会被忽略，而firefox、chrome和safari浏览器在比较早的版本就支持了，包括移动版。&lt;/p&gt;

&lt;p&gt;本文固定链接：&lt;a href=&quot;http://blog.comiclee.com/?p=218&quot;&gt;http://blog.comiclee.com/?p=218&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-8&quot;&gt;参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/&quot; target=&quot;_blank&quot;&gt;http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 20 Mar 2015 00:00:00 +0800</pubDate>
        <link>http://blog.comiclee.com/2015/03/javascript%e7%9a%84%e4%b8%a5%e6%a0%bc%e6%a8%a1%e5%bc%8f</link>
        <guid isPermaLink="true">http://blog.comiclee.com/2015/03/javascript%e7%9a%84%e4%b8%a5%e6%a0%bc%e6%a8%a1%e5%bc%8f</guid>
        
        <category>Javascript</category>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>异步提交文件</title>
        <description>&lt;p&gt;异步提交表单对于现代AJAX程序来说是一件轻而易举的事，如果使用jQuery等库的话更无需考虑浏览器的差异，简单的一句&lt;span class=&quot;lang:js decode:true  crayon-inline &quot;&gt;$.post&lt;/span&gt; 搞定，但如果要上传文件呢？jQuery的异步请求方法并没有提供异步提交文件的功能，这个时候我们可以使用jQuery的Form插件（&lt;a href=&quot;http://malsup.com/jquery/form/&quot; target=&quot;_blank&quot;&gt;http://malsup.com/jquery/form/&lt;/a&gt;）来完成这个功能，或者我们可以搞清楚原理，自己实现一个。&lt;!--more--&gt;&lt;/p&gt;

&lt;h1 id=&quot;jqueryform&quot;&gt;使用jQuery的form插件实现异步提交文件&lt;/h1&gt;

&lt;p&gt;使用form插件实现异步提交表单非常简单，只需要针对form表单执行ajaxForm初始化即可&lt;/p&gt;

&lt;pre class=&quot;lang:xhtml decode:true&quot;&gt;&amp;lt;form id=&quot;myForm&quot; action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&amp;gt;
  描述：&amp;lt;input name=&quot;desc&quot;&amp;gt;
  文件：&amp;lt;input name=&quot;file&quot; type=&quot;file&quot;&amp;gt;
  &amp;lt;button id=&quot;submit&quot; type=&quot;submit&quot;&amp;gt;提交&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;script&amp;gt;
$(&#39;#myForm&#39;).ajaxForm(function() { 
  alert(&quot;提交成功&quot;); 
}); 
&amp;lt;/script&amp;gt;&lt;/pre&gt;

&lt;h1 id=&quot;xmlhttprequest2&quot;&gt; XMLHttpRequest2对异步提交表单的支持&lt;/h1&gt;

&lt;p&gt;现代的浏览器对异步请求提供了功能更强大的支持，这就是我们要隆重介绍的XMLHttpRequest2。顺便提一句，XMLHttpRequest2并不属于HTML5，它是个新的、功能强大的API。我们可以构造XMLHttpRequest2的FormData对象并放进去我们想要的文本、文件等。&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true&quot;&gt;$(&#39;#myForm&#39;).on(&#39;submit&#39;, function() {
    var formElem = this;
    var formData = new FormData();
    $(&#39;#myForm&#39;).find(&#39;input&#39;).each(function() {
      if (this.type==&#39;file&#39; &amp;amp;&amp;amp; this.files.length&amp;gt;0) {
        for (var i= 0; i&amp;lt;this.files.length; i++) {
          formData.append(this.name, this.files.item(i));
        }
      } else {
        formData.append(this.name, this.value);
      }
    });

    $.ajax({
      url: formElem.action,
      data: formData,
      processData: false,
      contentType: false,
      type: formElem.method,
      success: function(data){
        alert(data);
      }
    });

    return false;
  });&lt;/pre&gt;

&lt;h1 id=&quot;section&quot;&gt; 低级浏览器下的解决方法&lt;/h1&gt;

&lt;p&gt;XMLHttpRequest2只有IE10+才支持，那么对于低版本的浏览器如何实现呢？我们可以构建一个虚拟表单，并提交到iframe里的方式。&lt;/p&gt;

&lt;pre class=&quot;lang:js decode:true&quot;&gt;$(&#39;#myForm&#39;).on(&#39;submit&#39;,function() {
    var jQorigForm = $(this);

    // 创建一个用于存放结果的iframe
    var iframeName = &#39;form-target-&#39;+new Date().valueOf();
    var jQiframe = $(&#39;&amp;lt;iframe id=&quot;&#39;+iframeName+&#39;&quot; name=&quot;&#39;+iframeName+&#39;&quot; style=&quot;position:absolute;left:-9999px;top:-9999px&quot;&amp;gt;&amp;lt;/iframe&amp;gt;&#39;)
      .appendTo(&#39;body&#39;);

    // 创建一个临时表单，令其提交到iframe中
    var jQform = jQorigForm.clone()
      .html(&#39;&#39;)
      .appendTo(&#39;body&#39;)
      .attr(&#39;target&#39;,iframeName)
      .css({position:&#39;absolute&#39;,left:&#39;-9999px&#39;,top:&#39;-9999px&#39;});

    // 拷贝输入框到临时表单
    jQorigForm.find(&#39;input&#39;).each(function() {
      var jQinput = $(this);
      var jQnewInput = jQinput.clone();
      if (this.type==&#39;file&#39;) { // 由于FileInput不能赋值，所以只能交换两个form的元素的权宜之计
        jQinput.before(jQnewInput);
        jQinput.appendTo(jQform);
      } else {
        jQnewInput.appendTo(jQform);
      }
    });

    // 提交临时表单
    jQform.submit().remove();

    // 设个定时从iframe中读取结果
    var interval = setInterval(function() {
      var content = jQiframe.contents().find(&#39;body&#39;).html();
      if (content) {
        alert(content);
        jQiframe.remove();
        clearInterval(interval);
      }
    }, 400);

    return false;
  });&lt;/pre&gt;

&lt;p&gt;本文固定链接：&lt;a href=&quot;http://blog.comiclee.com/?p=208&quot;&gt;http://blog.comiclee.com/?p=208&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.html5rocks.com/zh/tutorials/file/xhr2/&quot; target=&quot;_blank&quot;&gt;http://www.html5rocks.com/zh/tutorials/file/xhr2/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.zhangxinxu.com/wordpress/2013/10/understand-domstring-document-formdata-blob-file-arraybuffer/&quot; target=&quot;_blank&quot;&gt;http://www.zhangxinxu.com/wordpress/2013/10/understand-domstring-document-formdata-blob-file-arraybuffer/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/fengwei/archive/2012/06/22/2558567.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/fengwei/archive/2012/06/22/2558567.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 18 Mar 2015 00:00:00 +0800</pubDate>
        <link>http://blog.comiclee.com/2015/03/%e5%bc%82%e6%ad%a5%e6%8f%90%e4%ba%a4%e6%96%87%e4%bb%b6</link>
        <guid isPermaLink="true">http://blog.comiclee.com/2015/03/%e5%bc%82%e6%ad%a5%e6%8f%90%e4%ba%a4%e6%96%87%e4%bb%b6</guid>
        
        <category>XMLHttpRequest2</category>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>柴静雾霾调查：穹顶之下</title>
        <description>&lt;p&gt;保护环境，从你我做起！&lt;/p&gt;

&lt;p&gt;呃，被禁了&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Mar 2015 00:00:00 +0800</pubDate>
        <link>http://blog.comiclee.com/2015/03/%e6%9f%b4%e9%9d%99%e9%9b%be%e9%9c%be%e8%b0%83%e6%9f%a5%ef%bc%9a%e7%a9%b9%e9%a1%b6%e4%b9%8b%e4%b8%8b</link>
        <guid isPermaLink="true">http://blog.comiclee.com/2015/03/%e6%9f%b4%e9%9d%99%e9%9b%be%e9%9c%be%e8%b0%83%e6%9f%a5%ef%bc%9a%e7%a9%b9%e9%a1%b6%e4%b9%8b%e4%b8%8b</guid>
        
        
        <category>未分类</category>
        
      </item>
    
      <item>
        <title>BFC、浮动、清除和hasLayout</title>
        <description>&lt;p&gt;BFC——Block Formatting Context，块级格式化上下文，是CSS渲染的一个概念。我们在大多数的使用场景下并没有受到这个概念的影响，或者我们了解表象却不明白原因，所以容易忽视它，但遇到一些“诡异”的排版问题时，了解这个概念能够让我们更好地认清问题的本质。比如本文着重讲的和浮动有关的问题。&lt;!--more--&gt;&lt;/p&gt;

&lt;h1 id=&quot;bfc&quot;&gt;产生BFC的条件&lt;/h1&gt;

&lt;p&gt;以下情况会创建一个BFC：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;根元素或其它包含它的元素&lt;/li&gt;
  &lt;li&gt;浮动 (元素的 float 不为 none)&lt;/li&gt;
  &lt;li&gt;绝对定位元素 (元素的 position 为 absolute 或 fixed)&lt;/li&gt;
  &lt;li&gt;内联块 inline-blocks (元素的 display: inline-block)&lt;/li&gt;
  &lt;li&gt;表格单元格 (元素的 display: table-cell，HTML表格单元格默认属性)&lt;/li&gt;
  &lt;li&gt;表格标题 (元素的 display: table-caption, HTML表格标题默认属性)&lt;/li&gt;
  &lt;li&gt; overflow 的值不为 visible的元素&lt;/li&gt;
  &lt;li&gt;弹性盒 flex boxes (元素的 display: flex 或 inline-flex)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要注意区分BFC和块级元素，它们是不一样的概念，从上面的产生BFC的条件看，并非每个块级元素都会创建BFC。BFC相当于是一个虚拟空间，创造BFC的元素的子元素就处在这个空间中，而如果子元素符合创造BFC的条件，那么它也会创造独立的BFC，它的子孙就处于新的BFC中了。&lt;/p&gt;

&lt;h1 id=&quot;bfc-1&quot;&gt;BFC对于布局的影响&lt;/h1&gt;

&lt;p&gt;根据w3c的规范，在一个BFC中，盒子(boxes)从BFC的顶端往下，一个挨着一个垂直放置。相邻盒子之间的垂直距离取决于它们的margin属性，同一个BFC中，相邻块级盒子之间的垂直margin值会折叠。这句话包含几个限定条件，边距折叠的分析在以后的文章中再展开，这次仅注意到&lt;strong&gt;边距折叠只发生在同一个BFC中&lt;/strong&gt;。&lt;/p&gt;

&lt;h1 id=&quot;bfc-2&quot;&gt;BFC对浮动的影响&lt;/h1&gt;

&lt;p&gt;理解BFC的概念能够更好地理解浮动和清除时出现的现象。&lt;br /&gt;
根据w3c的规范，在BFC中，每个盒子的左外边缘(edge)都会触及BFC的左边缘，甚至浮动元素存在的时候也是这样（尽管盒子的行盒&lt;em&gt;line boxes&lt;/em&gt;会因为浮动元素而被压缩），除非盒子创建了一个新的BFC。&lt;/p&gt;

&lt;p&gt;例1：为了理解上面的话，我们做一个简单的实验，在3个盒子中设置中间的盒子是float:left的，可以看到，浮动元素后面的元素仍然靠着左边缘，尽管文字被挤压了。&lt;/p&gt;

&lt;table width=&quot;799.0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      &lt;style&gt;&lt;br /&gt; .small {width:50px; height:50px;}&lt;br /&gt; .middle {width:100px; height:100px;}&lt;br /&gt; .big {width:150px; height:150px;}&lt;br /&gt; .red {background-color:red;opacity:.5;}&lt;br /&gt; .yellow {background-color:yellow;opacity:.5;}&lt;br /&gt; .blue {background-color:blue;opacity:.5;}&lt;br /&gt; .float {float:left}&lt;br /&gt; .clear {clear:both}&lt;br /&gt; .newbfc {overflow:auto}&lt;br /&gt; &lt;/style&gt;&lt;br /&gt; &amp;lt;div class=&amp;#8221;middle yellow&amp;#8221;&amp;gt;&lt;br /&gt; &amp;lt;div class=&amp;#8221;middle red float&amp;#8221;&amp;gt;哈哈哈哈哈哈哈哈哈哈&lt;br /&gt; &amp;lt;div class=&amp;#8221;big blue&amp;#8221;&amp;gt;哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img class=&quot;alignnone  wp-image-155&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/1.jpeg&quot; alt=&quot;例1&quot; width=&quot;152&quot; height=&quot;235&quot; /&gt;&lt;/p&gt;

&lt;p&gt;例2：接下来，给浮动元素后面的div设置overflow:auto，使其创建BFC，于是它跑到浮动元素的右边了。这里选择overflow:auto，因为这个属性自身没有排列布局的功效，但是因为这样设置创建了BFC，最终影响到了它的位置&lt;/p&gt;

&lt;table width=&quot;799.0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      &amp;lt;div class=&amp;#8221;middle yellow&amp;#8221;&amp;gt;&lt;br /&gt; &amp;lt;div class=&amp;#8221;middle red float&amp;#8221;&amp;gt;哈哈哈哈哈哈哈哈哈哈&lt;br /&gt; &amp;lt;div class=&amp;#8221;big blue &lt;span style=&quot;color: #ff2600;&quot;&gt;newbfc&lt;/span&gt;&amp;#8220;&amp;gt;哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img class=&quot;alignnone  wp-image-156&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/2.jpeg&quot; alt=&quot;例2&quot; width=&quot;244&quot; height=&quot;239&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;浮动和清除&lt;/h1&gt;

&lt;p&gt;clear属性用于清除浮动，它将元素移动到浮动元素的下方。而该属性起作用的元素并不需要是浮动元素的兄弟元素，为了解释这一设定，可以构造出复杂的嵌套来分析其产生特殊布局的原因。不过我们还是把问题说得简单一点，以便于理解。&lt;/p&gt;

&lt;p&gt;例3：我们仍然对例1进行一些修改，这一次，我们在蓝色的盒子里放一个小的带有clear属性的盒子，同时再给蓝色的盒子设置一个左边距&lt;/p&gt;

&lt;table width=&quot;799.0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      &amp;lt;div class=&amp;#8221;middle yellow&amp;#8221;&amp;gt;&lt;br /&gt; &amp;lt;div class=&amp;#8221;middle red float&amp;#8221;&amp;gt;哈哈哈哈哈哈哈哈哈哈&lt;br /&gt; &amp;lt;div class=&amp;#8221;big blue&amp;#8221; style=&amp;#8221;margin-left:150px&amp;#8221;&amp;gt;&lt;br /&gt; &amp;lt;div class=&amp;#8221;small yellow &lt;span style=&quot;color: #ff2600;&quot;&gt;clear&lt;/span&gt;&amp;#8220;&amp;gt;&lt;br /&gt; 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈&lt;br /&gt; 
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img class=&quot;alignnone  wp-image-157&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/3.jpeg&quot; alt=&quot;例3&quot; width=&quot;250&quot; height=&quot;279&quot; /&gt;&lt;br /&gt;
结果是不是和你想的一样呢？哈哈。蓝色盒子里的小黄盒子（由于颜色叠加的原因，它变成了不知什么色）左边距离浮动的红盒子那么远，可还是不敢和红盒平起平坐，只能委屈地在红盒的下面。因为蓝盒及其子元素仍然处在先前的BFC中，所以它的clear属性是仍然能和浮动元素发生作用的，这一场景我们常常能在运用浮动时遇到，特别是在蓝盒中也有浮动元素的情况下，如下面例4&lt;/p&gt;

&lt;p&gt;例4：&lt;/p&gt;

&lt;table width=&quot;799.0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      &amp;lt;div class=&amp;#8221;middle yellow&amp;#8221;&amp;gt;&lt;br /&gt; &amp;lt;div class=&amp;#8221;middle red &lt;span style=&quot;color: #ff2600;&quot;&gt;float&lt;/span&gt;&amp;#8220;&amp;gt;哈哈哈哈哈哈哈哈哈哈&lt;br /&gt; &amp;lt;div class=&amp;#8221;big blue&amp;#8221; style=&amp;#8221;margin-left:150px&amp;#8221;&amp;gt;&lt;br /&gt; &amp;lt;div class=&amp;#8221;small yellow &lt;span style=&quot;color: #ff2600;&quot;&gt;float&lt;/span&gt;”&amp;gt;5&lt;br /&gt; &amp;lt;div class=&amp;#8221;small yellow &lt;span style=&quot;color: #ff2600;&quot;&gt;clear&lt;/span&gt;”&amp;gt;4&lt;br /&gt; 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈&lt;br /&gt; 
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img class=&quot;alignnone  wp-image-158&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/4.jpeg&quot; alt=&quot;例4&quot; width=&quot;248&quot; height=&quot;270&quot; /&gt;&lt;br /&gt;
我们只是想让div4清除div5的浮动的影响，但是因为红色浮动元素的影响，导致它并没有直接排在div5下边，而是排在红色块下缘的水平线以下。那如何达到我们想实现的效果呢？借用前面说的BFC的知识，我们给蓝色方块创建一个BFC：&lt;/p&gt;

&lt;p&gt;例5：&lt;/p&gt;

&lt;table width=&quot;799.0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      &amp;lt;div class=&amp;#8221;middle yellow&amp;#8221;&amp;gt;&lt;br /&gt; &amp;lt;div class=&amp;#8221;middle red float&amp;#8221;&amp;gt;哈哈哈哈哈哈哈哈哈哈&lt;br /&gt; &amp;lt;div class=&amp;#8221;big blue &lt;span style=&quot;color: #ff2600;&quot;&gt;newbfc&lt;/span&gt;&amp;#8221; style=&amp;#8221;margin-left:150px&amp;#8221;&amp;gt;&lt;br /&gt; &amp;lt;div class=&amp;#8221;small yellow float&amp;#8221;&amp;gt;5&lt;br /&gt; &amp;lt;div class=&amp;#8221;small yellow clear&amp;#8221;&amp;gt;4&lt;br /&gt; 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈&lt;br /&gt; 
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img class=&quot;alignnone  wp-image-159&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/5.jpeg&quot; alt=&quot;例5&quot; width=&quot;226&quot; height=&quot;195&quot; /&gt;&lt;br /&gt;
创建BFC有很多方法，都会产生一些副作用，所以按照实际需求选用一个即可。此处也可以选择display:inline-block触发BFC，而保持display:visible的效果，但也会引起其它的副作用，读者可以尝试一下。&lt;/p&gt;

&lt;h1 id=&quot;clearclearance&quot;&gt;clear元素的边距和clearance&lt;/h1&gt;

&lt;p&gt;最后介绍一下clearance。清除了浮动的元素，其margin-top值产生的效果可能在你的意料之外，我们继续修改例5，给方块4设置margin-top值为10px，-10px，60px看看.&lt;/p&gt;

&lt;p&gt;例6：&lt;br /&gt;
&lt;img class=&quot;alignleft  wp-image-160&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/61.jpeg&quot; alt=&quot;例6&quot; width=&quot;178&quot; height=&quot;151&quot; /&gt; &lt;img class=&quot;alignleft  wp-image-161&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/62.jpeg&quot; alt=&quot;例6&quot; width=&quot;179&quot; height=&quot;154&quot; /&gt; &lt;img class=&quot;alignleft  wp-image-162&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/63.jpeg&quot; alt=&quot;例6&quot; width=&quot;183&quot; height=&quot;154&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;clear: both;&quot;&gt;
  可以看出，margin-top设为10px和-10px都“没有作用”，利用开发者工具看元素的包围情况，可以看到方块4的上边距并没有把它和方块5拉开，好像是举着一根棍子，试图够着蓝色方块的上边缘，可以想象这跟棍子足够长的话就能抵到上边缘，并把方块4顶开（如将margin-top设为60px）。而中间还有的40px的空间就是clearance。
&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;alignnone  wp-image-163&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/64.jpeg&quot; alt=&quot;例6&quot; width=&quot;324&quot; height=&quot;209&quot; /&gt;&lt;br /&gt;
根据w3c的规范，clearance抑制边距折叠，并填充元素margin-top之上的空间，将元素在垂直方向推过浮动元素。它的值恰好让元素的边沿和被清除的浮动元素的下外边沿水平。我们在开发的时候不需要去计算clearance，只需要知道出现这种现象的原因是什么即可。&lt;/p&gt;

&lt;h1 id=&quot;ie67&quot;&gt;IE6,7下的效果&lt;/h1&gt;

&lt;p&gt;IE8以上的显示效果与w3c的规范一致，但在IE6,7（标准模式）下，显示效果又有所不同。造成这样的效果的原因一方面是由于其自身的bug，另一方面是由Layout（布局）造成的。我们先不讨论Layout，但是需要对例子做一些修改，我们把蓝盒的width和height样式属性去掉，通过增加其内部的文字把蓝盒撑大，并把浏览器窗口缩小以便看得更容易。由于IE6和IE7的显示效果差不多，如果没有太大的差别，我们就只用IE6举例。&lt;/p&gt;

&lt;p&gt;例1-1&lt;/p&gt;

&lt;pre class=&quot;lang:xhtml decode:true&quot;&gt;&amp;lt;style&amp;gt;
.small {width:50px; height:50px;}
.middle {width:100px; height:100px;}
.big {width:150px; height:150px;}
.red {background-color:red;filter:alpha(opacity=50);}
.yellow {background-color:yellow;filter:alpha(opacity=50);}
.blue {background-color:blue;filter:alpha(opacity=50);}
.float {float:left}
.clear {clear:both}
.newbfc {overflow:auto}
&amp;lt;/style&amp;gt;
&amp;lt;div class=&quot;middle yellow&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;middle red float&quot;&amp;gt;哈哈哈哈哈哈哈哈哈哈&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;blue&quot;&amp;gt;
哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈
&amp;lt;/div&amp;gt;&lt;/pre&gt;

&lt;p&gt;&lt;img class=&quot;alignnone  wp-image-172&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/QQ20150213-4@2x.png&quot; alt=&quot;例1-1&quot; width=&quot;240&quot; height=&quot;189&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其显示效果和例1差不多。然后我们看看例2在IE6下的效果：&lt;/p&gt;

&lt;p&gt;例2-1：&lt;/p&gt;

&lt;pre class=&quot;lang:xhtml decode:true&quot;&gt;&amp;lt;div class=&quot;middle yellow&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;middle red float&quot;&amp;gt;哈哈哈哈哈哈哈哈哈哈&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;blue &lt;span style=&quot;color: #ff0000;&quot;&gt;newbfc&lt;/span&gt;&quot;&amp;gt;
哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈
&amp;lt;/div&amp;gt;&lt;/pre&gt;

&lt;p&gt;IE6：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;alignnone  wp-image-172&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/QQ20150213-4@2x.png&quot; alt=&quot;例1-1&quot; width=&quot;240&quot; height=&quot;189&quot; /&gt;&lt;/p&gt;

&lt;p&gt;IE7：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;alignnone  wp-image-173&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/QQ20150213-5@2x.png&quot; alt=&quot;例2-1&quot; width=&quot;232&quot; height=&quot;310&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过设置overflow:auto，在IE6下无效，在IE7下却能显示出创建了新的BFC后的效果。&lt;/p&gt;

&lt;p&gt;例3-1：&lt;/p&gt;

&lt;pre class=&quot;lang:xhtml decode:true&quot;&gt;&amp;lt;div class=&quot;middle yellow&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;middle red float&quot;&amp;gt;哈哈哈哈哈哈哈哈哈哈&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;blue&quot; style=&quot;margin-left:150px&quot;&amp;gt;
  &amp;lt;div class=&quot;small yellow clear&quot;&amp;gt;&amp;lt;/div&amp;gt;
  哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈
&amp;lt;/div&amp;gt;&lt;/pre&gt;

&lt;p&gt;&lt;img class=&quot;alignnone  wp-image-174&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/QQ20150213-6@2x.png&quot; alt=&quot;例3-1&quot; width=&quot;234&quot; height=&quot;303&quot; /&gt;&lt;/p&gt;

&lt;p&gt;咦，好像出现了类似bug的东西。拥有clear属性的方块不但自己跑了下来，还把外层的蓝色方块也拉了下来。嗯，其实这里是发生了边距折叠，我们可以给蓝块设置一个border-top来试验一下&lt;/p&gt;

&lt;p&gt;例3-1-1：&lt;/p&gt;

&lt;pre class=&quot;lang:xhtml decode:true&quot;&gt;&amp;lt;div class=&quot;middle yellow&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;middle red float&quot;&amp;gt;哈哈哈哈哈哈哈哈哈哈&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;blue&quot; style=&quot;margin-left:150px;border-top:1px dashed;&quot;&amp;gt;
  &amp;lt;div class=&quot;small yellow clear&quot;&amp;gt;&amp;lt;/div&amp;gt;
  哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈
&amp;lt;/div&amp;gt;&lt;/pre&gt;

&lt;p&gt;&lt;img class=&quot;alignnone  wp-image-175&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/QQ20150213-7@2x.png&quot; alt=&quot;例3-1-1&quot; width=&quot;224&quot; height=&quot;229&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但这里的边距折叠是IE6、7的一个bug，因为根据w3c规定，clear元素不会发生边距折叠。&lt;/p&gt;

&lt;p&gt;接下来看看例4，这个表现和预想的一致&lt;/p&gt;

&lt;p&gt;例4-1：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;alignnone  wp-image-176&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/QQ20150213-8@2x.png&quot; alt=&quot;例4-1&quot; width=&quot;223&quot; height=&quot;224&quot; /&gt;&lt;/p&gt;

&lt;p&gt;例5在IE6和IE7下也是有差别的，IE7同样能显示出创建新bfc后的效果，而IE6却没有变化&lt;/p&gt;

&lt;p&gt;例5-1&lt;/p&gt;

&lt;p&gt;IE6：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;alignnone  wp-image-177&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/QQ20150213-9@2x.png&quot; alt=&quot;例5-1&quot; width=&quot;216&quot; height=&quot;196&quot; /&gt;&lt;/p&gt;

&lt;p&gt;IE7：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;alignnone  wp-image-178&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/QQ20150213-10@2x.png&quot; alt=&quot;例5-1&quot; width=&quot;212&quot; height=&quot;179&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后我们看看clearance在IE6、7下的表现如何&lt;/p&gt;

&lt;p&gt;例6-1&lt;/p&gt;

&lt;p&gt;IE6&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;alignnone  wp-image-179&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/QQ20150213-13@2x.png&quot; alt=&quot;例6-1&quot; width=&quot;212&quot; height=&quot;197&quot; /&gt;&lt;img class=&quot;alignnone  wp-image-180&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/QQ20150213-14@2x.png&quot; alt=&quot;例6-1&quot; width=&quot;198&quot; height=&quot;196&quot; /&gt;&lt;/p&gt;

&lt;p&gt;IE7&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;alignnone  wp-image-181&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/QQ20150213-11@2x.png&quot; alt=&quot;例6-1&quot; width=&quot;204&quot; height=&quot;179&quot; /&gt;&lt;img class=&quot;alignnone  wp-image-182&quot; src=&quot;http://blog.comiclee.com/wp-content/uploads/2015/02/QQ20150213-12@2x.png&quot; alt=&quot;例6-1&quot; width=&quot;210&quot; height=&quot;178&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在IE6、7下根本没有clearance的概念，它的行为却更符合我们一般的认识。由于IE6、7和其它浏览器的这一差别，&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;strong&gt;我们对待clear元素要更加慎重一些，尽量避免需要专门给IE6、7做hack的情况&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;最后我们看看为什么newbfc这个class在IE7下似乎是生效的，而在IE6下却不生效。这就引出IE6、7下特有的概念——hasLayout&lt;/p&gt;

&lt;h1 id=&quot;haslayout&quot;&gt;hasLayout&lt;/h1&gt;

&lt;p&gt;hasLayout是在IE6、7下特有的概念，在IE8以后就废弃了。一个元素触发hasLayout的效果类似于其创建了新的BFC。&lt;/p&gt;

&lt;p&gt;那么要如何触发hasLayout呢？默认拥有布局的元素有：&lt;/p&gt;

&lt;p&gt;html，body，table，tr，th，td，iframe，object, applet，img，hr，input，button，select，textarea，fieldset，legend等。&lt;/p&gt;

&lt;p&gt;设置以下属性会使一个元素拥有布局：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;position:absolute&lt;/li&gt;
  &lt;li&gt;float:left or right&lt;/li&gt;
  &lt;li&gt;display:inline-block&lt;/li&gt;
  &lt;li&gt;width:any value other than auto&lt;/li&gt;
  &lt;li&gt;height:any value other than auto&lt;/li&gt;
  &lt;li&gt;zoom:any value other than normal&lt;/li&gt;
  &lt;li&gt;writing-mode:tb-rl&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;IE7还可以通过以下属性设置hasLayout：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;overflow:hidden or scroll or auto&lt;/li&gt;
  &lt;li&gt;overflow-x:hidden or scroll or auto&lt;/li&gt;
  &lt;li&gt;overflow-y:hidden or scroll or auto&lt;/li&gt;
  &lt;li&gt;min-width:any value other than auto&lt;/li&gt;
  &lt;li&gt;max-width:any value other than auto&lt;/li&gt;
  &lt;li&gt;min-height:any value other than auto&lt;/li&gt;
  &lt;li&gt;max-height:any value other than auto&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看出，在上面的例子中，设置overflow:auto是可以在IE7中触发hasLayout的，而在IE6中不行，不过只需要给元素设置width或height属性就可以让其拥有布局。所以我们在布局的时候，为了达到浏览器显示的一致性，往往需要考虑&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;strong&gt;同时触发hasLayout以及创建BFC&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;参考资料&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.w3.org/TR/CSS21/visuren.html#block-formatting&quot; target=&quot;_blank&quot;&gt;http://www.w3.org/TR/CSS21/visuren.html#block-formatting&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/Block_formatting_context&quot; target=&quot;_blank&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/CSS/Block_formatting_context&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.sitepoint.com/web-foundations/internet-explorer-haslayout-property/&quot; target=&quot;_blank&quot;&gt;http://www.sitepoint.com/web-foundations/internet-explorer-haslayout-property/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本文固定链接：&lt;a href=&quot;http://blog.comiclee.com/?p=154&quot;&gt;http://blog.comiclee.com/?p=154&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 12 Feb 2015 00:00:00 +0800</pubDate>
        <link>http://blog.comiclee.com/2015/02/bfc%e6%b5%ae%e5%8a%a8%e6%b8%85%e9%99%a4%e5%92%8chaslayout</link>
        <guid isPermaLink="true">http://blog.comiclee.com/2015/02/bfc%e6%b5%ae%e5%8a%a8%e6%b8%85%e9%99%a4%e5%92%8chaslayout</guid>
        
        <category>css</category>
        
        
        <category>css</category>
        
      </item>
    
      <item>
        <title>ECMAScript5新特性</title>
        <description>&lt;p&gt;现在写这篇文章有点晚了，毕竟ECMAScript5在2009年就发布了。但是当时支持的浏览器还很少，经过这几年的发展，主流浏览器对ECMAScript5已经大都支持了（不过IE8仍然占有很大的份额），我们再重新看看ECMAScript5里有哪些新特性我们可用的。&lt;/p&gt;

&lt;p&gt;ECMAScript支持的浏览器为IE9+，chrome23+，safari6+，IOS7/8，其它份额很小的浏览器我就没有列出来了，具体可以看 &lt;a href=&quot;http://kangax.github.io/compat-table/es5/&quot;&gt;http://kangax.github.io/compat-table/es5/&lt;/a&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; style=&quot;table-layout: fixed&quot;&gt;
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Object.create
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      创建一个拥有指定原型和若干个指定属性的对象
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Object.defineProperty
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      该方法允许精确添加或修改对象的属性。正常的属性添加通过赋值来创建并显示在属性枚举中（for&amp;#8230;in 循环 或 Object.keys 方法）， 这种方式添加的属性值可能被改变，也可能会被 删除。该方法允许改变这些额外细节的默认设置。
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      可以定义这个属性的特性，如writable, get, set, confiurable, enumerable
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Object.defineProperties
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      批量defineProperty
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Object.getPrototypeOf
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      返回指定对象的原型（也就是该对象内部属性[[Prototype]]的值）
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Object.keys
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Object.seal
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      让一个对象密封，并返回被密封后的对象。密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      检测：Object.isSealed
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Object.freeze
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      冻结一个对象。冻结对象是指那些不能添加新的属性，不能修改已有属性的值，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性的对象。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      和seal相比，值都不能改了检测：Object.isFrozen
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Object.preventExtensions
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      让一个对象变的不可扩展，也就是永远不能再添加新的属性
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      检测：Object.isExtensible
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Object.getOwnPropertyDescriptor
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      返回其writable, get, set, confiurable, enumerable属性
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Object.getOwnPropertyNames
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组。
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      和keys的区别是它可以列出不可枚举的值
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Date.prototype.toISOString
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      返回一个 ISO（ISO 8601 Extended Format）格式的字符串： YYYY-MM-DDTHH:mm:ss.sssZ。时区总是UTC（协调世界时），加一个后缀“Z”标识
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Date.now
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      返回自1970年1月1日 00:00:00 UTC到当前时间的毫秒数
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Array.isArray
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      判断一个对象是否为数组,如果是,则返回true,否则返回false.
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      JSON
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      parse 解析JSON字符串, 可以选择改变前面解析后的值及其属性，然后返回解析的值。&lt;br /&gt; stringify 返回指定值的 JSON 字符串，可以自定义只包含某些特定的属性或替换属性值。
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      &lt;span style=&quot;color: #ff2600;&quot;&gt;IE8支持&lt;/span&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Function.prototype.bind
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      创建一个新函数,称为绑定函数.当调用这个绑定函数时,绑定函数会以创建它时传入 bind()方法的第一个参数作为 this,传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数.
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      String.prototype.trim
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      删除字符串两端的空白字符并返回.
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Array.prototype.indexOf
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      返回根据给定元素找到的第一个索引值，否则返回-1
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Array.prototype.lastIndexOf
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Array.prototype.every
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 falsy（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Array.prototype.some
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      测试数组中的某些元素是否通过了指定函数的测试
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Array.prototype.forEach
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      让数组的每一项都执行一次给定的函数
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Array.prototype.map
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值组合起来形成一个新数组。 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Array.prototype.filter
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回“真值”（即可转换为布尔值 true 的值）的元素创建一个新数组。callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素只会被跳过，不会被包含在新数组中。
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Array.prototype.reduce
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Array.prototype.reduceRight
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      接受一个函数作为累加器（accumulator），让每个值（从右到左，亦即从尾到头）缩减为一个值。（与 reduce() 的执行方向相反）
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      getter和setter
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      var o={_name :&amp;#8217;o&amp;#8217;, get name(){return this._name}, set name(v) {this._name=v}};console.log(o.name);    //‘o&amp;#8217;
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Property access on strings
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      &amp;#8216;foobar&#39;[3]==&amp;#8217;b&amp;#8217;
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      &lt;span style=&quot;color: #ff2600;&quot;&gt;IE8支持&lt;/span&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      保留字作为对象属性
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      a={if:1}
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      0宽度字符作为名称
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      var _\u200c\u200d = true;&lt;br /&gt; return _\u200c\u200d;
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      parseInt忽视开头的&amp;#8217;0&amp;#8242;
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      parseInt(&amp;#8216;010&amp;#8242;) === 10;
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      undefined不可变
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td valign=&quot;top&quot;&gt;
      Strict mode
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
      (function () {&amp;#8220;use strict&amp;#8221;;return !this;}())
    &lt;/td&gt;
    
    &lt;td valign=&quot;top&quot;&gt;
       &lt;span style=&quot;color: #ff2600;&quot;&gt;IE9不支持&lt;/span&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</description>
        <pubDate>Tue, 27 Jan 2015 00:00:00 +0800</pubDate>
        <link>http://blog.comiclee.com/2015/01/ecmascript5%e6%96%b0%e7%89%b9%e6%80%a7</link>
        <guid isPermaLink="true">http://blog.comiclee.com/2015/01/ecmascript5%e6%96%b0%e7%89%b9%e6%80%a7</guid>
        
        <category>Javascript</category>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>计算一个目录的md5值</title>
        <description>&lt;p&gt;使用Linux的md5sum命令可以计算出一个文件的md5值，这可以用于判断文件是否经过更改，使用方法如下：&lt;/p&gt;

&lt;pre&gt;md5sum filename&lt;/pre&gt;

&lt;p&gt;但md5sum命令无法作用于一个目录，那如何计算一个目录的md5呢？有一个思路是计算目录内所有文件的md5，然后再进行一次的md5计算。我们可以遍历目录，对所有文件进行计算：&lt;!--more--&gt;&lt;/p&gt;

&lt;pre&gt;sum=&#39;&#39;
process() {
  local dir=$1
  for file in `ls $dir` ; do
    local path=$dir/$file
    if [ -d $path ] ; then
      process $path 
    elif [ -f $path ] ; then
      sum=$sum$(md5sum $path)
    fi
  done
}
process pathname
echo $sum | md5sum&lt;/pre&gt;

&lt;p&gt;其实利用Linux的find命令，能够更方便快捷地达成目的&lt;/p&gt;

&lt;pre&gt;find pathname -type f | xargs md5sum | md5sum&lt;/pre&gt;

&lt;p&gt;当然，用这两种方法计算的md5是不一样的，要保证使用同一个md5算法，以免出问题。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
</description>
        <pubDate>Fri, 09 Jan 2015 00:00:00 +0800</pubDate>
        <link>http://blog.comiclee.com/2015/01/%e8%ae%a1%e7%ae%97%e4%b8%80%e4%b8%aa%e7%9b%ae%e5%bd%95%e7%9a%84md5%e5%80%bc</link>
        <guid isPermaLink="true">http://blog.comiclee.com/2015/01/%e8%ae%a1%e7%ae%97%e4%b8%80%e4%b8%aa%e7%9b%ae%e5%bd%95%e7%9a%84md5%e5%80%bc</guid>
        
        <category>Linux</category>
        
        
        <category>Linux</category>
        
      </item>
    
  </channel>
</rss>
