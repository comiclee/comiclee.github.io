<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>gulp实践</title>
  <meta name="description" content="什么是gulp">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://blog.comiclee.com/2014/10/gulp%e5%ae%9e%e8%b7%b5">
  <link rel="alternate" type="application/rss+xml" title="前端栗仔 | Thinking in Front-end" href="http://blog.comiclee.com/feed.xml" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">前端栗仔 | Thinking in Front-end</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
          <a class="page-link" href="/about/">关于我</a>
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">gulp实践</h1>
    <p class="post-meta">Oct 12, 2014 • comiclee</p>
  </header>

  <article class="post-content">
    <h1 id="gulp">什么是gulp</h1>

<p>gulp是一种自动化构建工具，基于Node.js，主要用于前端模块的构建，包括对js、css（以及sass、less、CoffeeScript）的编译、打包、压缩、添加版本号等。</p>

<h1 id="gulp-1">为什么使用gulp</h1>

<p>前端构建工具最有名的当属grunt了，grunt有庞大的插件群来处理各种任务。它们对外暴露的接口是一堆的配置项，这是很方便的，但是当任务变得复杂，配置项变得越来越多时，这种配置的方式变得更加复杂，不太直观。</p>

<p>对于程序员来说，能够清晰看到程序的运行流程是更好的方式，gulp是一种流式的任务管理工具，可以看到任务中的对数据流的操作过程，这个对程序员来说更易于理解。<!--more--></p>

<p>其它的诸如fis等集成解决方案太重了，一般都需要以一定的规范和框架组织代码，对模板语言也有限制，不够灵活。</p>

<h1 id="gulp-2">开始使用gulp</h1>

<ol>
  <li>
    <p>在全局环境中安装gulp，以便于直接使用gulp命令 &lt;pre class="lang:sh decode:true"&gt;npm install gulp -g&lt;/pre&gt;</p>
  </li>
  <li>
    <p>安装gulp到当前项目中，使得可以通过require加载gulp模块。同时安装其它的几个需要的插件，下面举例使用gulp-rev-all插件来完成给静态资源打版本号的操作。这个插件并没有处理css中的图片，所以我们再使用一个gulp-rev-css-url插件来完成这个工作。 &lt;pre class="lang:sh decode:true"&gt;npm install gulp –save
npm install gulp-rev-all –save
npm install gulp-rev-css-url –save&lt;/pre&gt;</p>
  </li>
  <li>
    <p>在gulp执行目录下创建一个gulpfile.js文件，把需要做的操作写在该文件中。 &lt;pre class="lang:js decode:true"&gt;var gulp = require(‘gulp’);
var revall = require(‘gulp-rev-all’);
var revcss = require(‘gulp-rev-css-url’);
gulp.task(‘revall’, function () {
   return gulp.src([
‘../static/css/<strong>/<em>.css’,
‘../static/js/**/</em>.js’,
‘../static/img/</strong>/<em>.</em>’,
‘../static/html/<em>*/</em>.html’,
‘../WEB-INF/views/<em>*/</em>.ftl’
   ],{base:’../’})
   .pipe(revall({
ignore: [‘.xml’, ‘.html’, ‘.ftl’],
transformPath: function (rev, source, path) {
  return rev.replace(‘/static’, ‘http://cdn.mycompany.com’);
}
   }))
   .pipe(gulp.dest(‘../’))
   .pipe(revcss())
   .pipe(gulp.dest(‘../’))
   .pipe(revall.manifest())
   .pipe(gulp.dest(‘../’));
});
gulp.task(‘default’, [‘revall’]);</p>
  </li>
</ol>
<p>&lt;/pre&gt;</p>

<div class="highlighter-rouge"><pre class="highlight"><code>以上代码定义了一个叫revall的task，和default的task，我们执行

&lt;pre class="lang:sh decode:true"&gt;gulp revall&lt;/pre&gt;

就可以直接运行revall的task。或者执行

&lt;pre class="lang:sh decode:true"&gt;gulp&lt;/pre&gt;

直接运行默认的task&lt;/li&gt; 

  * 编写自己的task。本文先介绍使用普通的方式编写task，即非流式的形式，这很简单，能够方便的和现有的编译脚本整合： &lt;pre class="lang:js decode:true "&gt;gulp.task('init',function() {   require('./init.js'); }); gulp.task('revall', ['init'], function () {   ... });
</code></pre>
</div>
<p>&lt;/pre&gt;</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    我们定义了一个叫init的task，在这个task中使用普通的Node语句来写，并没有使用gulp的流式处理的写法。同时，我们修改了revall的定义，使其依赖于init。&lt;/li&gt; &lt;/ol&gt; 
    
    # gulp的执行顺序
    
    上面内容定义了2个顺序执行的task。这里对gulp的执行顺序多说几句：
    
      1. revall会等到所依赖的init task执行完毕后执行，如果它依赖多个task，如：[&amp;#8216;init&amp;#8217;, &amp;#8216;task1&amp;#8242;, &amp;#8216;task2&amp;#8242;, &amp;#8230;]，则这些task会依次执行结束后再执行revall。由于这些task是异步执行的，所以task1开始执行时，init可能还未结束，如果要定义严格的执行顺序，则需要让task1依赖于init。
      2. task代码执行结束时，数据流的操作不一定结束，这使得一个task执行时，它所依赖的task仍然还没有执行完，最简单的解决方法是在task定义的函数中return最后一个数据流对象。
    
    参考文章
    
      1. &lt;a href="https://github.com/gulpjs/gulp/blob/master/docs/README.md" target="_blank"&gt;gulp documentation&lt;/a&gt;
      2. &lt;a title="Gulp：任务自动管理工具" href="http://javascript.ruanyifeng.com/tool/gulp.html" target="_blank"&gt;Gulp：任务自动管理工具&lt;/a&gt;
      3. &lt;a title="前端工程化：在gulp中顺序执行任务" href="http://www.lifelaf.com/blog/?p=1210" target="_blank"&gt;前端工程化：在gulp中顺序执行任务&lt;/a&gt;
    
    &amp;nbsp;
</code></pre>
</div>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">前端栗仔 | Thinking in Front-end</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>前端栗仔 | Thinking in Front-end</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Thinking in Front-end</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
